import Foundation
import SwiftUI

final class MockDataService: ObservableObject {
    @Published var auctions: [Auction] = []
    @Published var featuredAuctions: [Auction] = []
    @Published var currentUser: User

    static let shared = MockDataService()

    private init() {
        self.currentUser = Self.generateMockUser()
        let allAuctions = Self.generateMockAuctions()
        self.auctions = allAuctions
        self.featuredAuctions = Array(allAuctions.prefix(3))
    }

    // MARK: - Mock User

    private static func generateMockUser() -> User {
        User(
            id: UUID(),
            username: "artcollector",
            displayName: "Alex G.",
            walletAddress: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
            avatarName: nil,
            bio: "Digital art enthusiast & NFT collector",
            ownedArtworks: [],
            favoritedArtworks: []
        )
    }

    // MARK: - Mock Artworks

    private static let artworkData: [(String, String, String, NFTArtwork.ArtworkCategory, [Color])] = [
        ("Cosmic Dreams", "Elena Vasquez", "A mesmerizing journey through digital cosmos, blending vibrant nebulae with abstract geometric forms.", .digitalPainting, [.purple, .blue, .pink]),
        ("Neural Garden", "Kai Tanaka", "Generated by a custom neural network trained on botanical illustrations from the 18th century.", .generativeArt, [.green, .teal, .mint]),
        ("Neon District", "Marcus Chen", "Cyberpunk-inspired urban landscape captured through the lens of AI-enhanced photography.", .photography, [.cyan, .blue, .indigo]),
        ("Ethereal Flow", "Sofia Andersen", "Abstract representation of blockchain data flows, visualized as luminous streams of energy.", .abstract, [.orange, .pink, .red]),
        ("Pixel Samurai", "Yuki Mori", "A tribute to Japanese warrior culture rendered in a retro 32-bit pixel art style.", .pixel, [.red, .orange, .yellow]),
        ("Crystal Matrix", "David Park", "3D-rendered crystalline structures inspired by molecular geometry and sacred patterns.", .threeD, [.cyan, .purple, .blue]),
        ("Digital Sunrise", "Amara Okafor", "Breathtaking digital landscape capturing the first light over a futuristic cityscape.", .digitalPainting, [.orange, .yellow, .pink]),
        ("Quantum Bloom", "Leo Fischer", "Generative floral patterns emerging from quantum probability distributions.", .generativeArt, [.pink, .purple, .white]),
        ("Urban Reflections", "Nina Volkov", "Street photography reimagined through fractal mirror algorithms.", .photography, [.gray, .blue, .cyan]),
        ("Void Walker", "Rex Sterling", "Abstract exploration of negative space and dimensional boundaries.", .abstract, [.black, .purple, .indigo]),
        ("Crypto Cats", "Mia Zhang", "Playful pixel art collection celebrating the intersection of cats and cryptography.", .pixel, [.yellow, .orange, .green]),
        ("Holographic Temple", "Arjun Patel", "Sacred architecture reconstructed as a holographic 3D environment.", .threeD, [.indigo, .purple, .cyan]),
    ]

    private static func generateMockArtworks() -> [NFTArtwork] {
        artworkData.enumerated().map { index, data in
            NFTArtwork(
                id: UUID(),
                title: data.0,
                artistName: data.1,
                description: data.2,
                imageName: "artwork_\(index)",
                category: data.3,
                createdAt: Date().addingTimeInterval(-Double(index) * 86400),
                tokenId: String(format: "%04d", index + 1),
                contractAddress: "0x\(String(repeating: "a", count: 40))",
                blockchain: index % 2 == 0 ? .ethereum : .polygon
            )
        }
    }

    // MARK: - Mock Auctions

    private static func generateMockAuctions() -> [Auction] {
        let artworks = generateMockArtworks()
        let bidders = [
            ("CryptoWhale", UUID()),
            ("ArtLover42", UUID()),
            ("NFTHunter", UUID()),
            ("DigitalDragon", UUID()),
            ("BlockBuster", UUID()),
        ]

        return artworks.enumerated().map { index, artwork in
            let startingPrice = Double.random(in: 0.1...5.0)
            let bidCount = Int.random(in: 0...8)
            var currentBid = startingPrice
            var bids: [Bid] = []

            for i in 0..<bidCount {
                let increment = Double.random(in: 0.05...0.5)
                currentBid += increment
                let bidder = bidders[i % bidders.count]
                bids.append(Bid(
                    id: UUID(),
                    userId: bidder.1,
                    userName: bidder.0,
                    amount: currentBid,
                    timestamp: Date().addingTimeInterval(-Double(bidCount - i) * 3600)
                ))
            }

            let hoursRemaining = Double.random(in: 1...72)
            let status: Auction.AuctionStatus = index < 10 ? .active : .upcoming

            return Auction(
                id: UUID(),
                artwork: artwork,
                startTime: Date().addingTimeInterval(-Double.random(in: 3600...86400)),
                endTime: Date().addingTimeInterval(hoursRemaining * 3600),
                currentBid: currentBid,
                bids: bids,
                status: status,
                startingPrice: startingPrice,
                reservePrice: startingPrice * 2
            )
        }
    }

    // MARK: - Procedural Artwork Image Generation

    static func generateArtworkImage(for artwork: NFTArtwork, size: CGSize = CGSize(width: 400, height: 400)) -> UIImage {
        let colors = artworkColors(for: artwork)
        return generateProceduralImage(colors: colors, seed: artwork.id.hashValue, size: size)
    }

    private static func artworkColors(for artwork: NFTArtwork) -> [Color] {
        if let index = artworkData.firstIndex(where: { $0.0 == artwork.title }) {
            return artworkData[index].4
        }
        return [.purple, .blue]
    }

    private static func generateProceduralImage(colors: [Color], seed: Int, size: CGSize) -> UIImage {
        let renderer = UIGraphicsImageRenderer(size: size)
        return renderer.image { context in
            let ctx = context.cgContext

            // Background gradient
            let uiColors = colors.map { UIColor($0) }
            let cgColors = uiColors.map { $0.cgColor }
            if let gradient = CGGradient(colorsSpace: CGColorSpaceCreateDeviceRGB(),
                                          colors: cgColors as CFArray,
                                          locations: nil) {
                ctx.drawLinearGradient(gradient,
                                       start: CGPoint(x: 0, y: 0),
                                       end: CGPoint(x: size.width, y: size.height),
                                       options: [])
            }

            // Procedural shapes based on seed
            var rng = SeededRNG(seed: seed)

            // Circles
            for _ in 0..<Int.random(in: 5...15, using: &rng) {
                let radius = CGFloat.random(in: 20...120, using: &rng)
                let x = CGFloat.random(in: -radius...size.width, using: &rng)
                let y = CGFloat.random(in: -radius...size.height, using: &rng)
                let alpha = CGFloat.random(in: 0.05...0.3, using: &rng)

                let colorIndex = Int.random(in: 0..<uiColors.count, using: &rng)
                ctx.setFillColor(uiColors[colorIndex].withAlphaComponent(alpha).cgColor)
                ctx.fillEllipse(in: CGRect(x: x, y: y, width: radius * 2, height: radius * 2))
            }

            // Lines
            for _ in 0..<Int.random(in: 3...8, using: &rng) {
                let lineWidth = CGFloat.random(in: 1...4, using: &rng)
                ctx.setLineWidth(lineWidth)
                let alpha = CGFloat.random(in: 0.1...0.5, using: &rng)
                let colorIndex = Int.random(in: 0..<uiColors.count, using: &rng)
                ctx.setStrokeColor(uiColors[colorIndex].withAlphaComponent(alpha).cgColor)
                ctx.move(to: CGPoint(
                    x: CGFloat.random(in: 0...size.width, using: &rng),
                    y: CGFloat.random(in: 0...size.height, using: &rng)
                ))
                ctx.addLine(to: CGPoint(
                    x: CGFloat.random(in: 0...size.width, using: &rng),
                    y: CGFloat.random(in: 0...size.height, using: &rng)
                ))
                ctx.strokePath()
            }

            // Rounded rects
            for _ in 0..<Int.random(in: 2...6, using: &rng) {
                let w = CGFloat.random(in: 30...150, using: &rng)
                let h = CGFloat.random(in: 30...150, using: &rng)
                let x = CGFloat.random(in: 0...size.width - w, using: &rng)
                let y = CGFloat.random(in: 0...size.height - h, using: &rng)
                let alpha = CGFloat.random(in: 0.05...0.25, using: &rng)
                let colorIndex = Int.random(in: 0..<uiColors.count, using: &rng)

                let path = UIBezierPath(roundedRect: CGRect(x: x, y: y, width: w, height: h), cornerRadius: 8)
                ctx.setFillColor(uiColors[colorIndex].withAlphaComponent(alpha).cgColor)
                ctx.addPath(path.cgPath)
                ctx.fillPath()
            }

            // Noise overlay
            for x in stride(from: 0, to: Int(size.width), by: 4) {
                for y in stride(from: 0, to: Int(size.height), by: 4) {
                    let noise = CGFloat.random(in: 0...1, using: &rng)
                    if noise > 0.97 {
                        ctx.setFillColor(UIColor.white.withAlphaComponent(0.08).cgColor)
                        ctx.fill(CGRect(x: x, y: y, width: 2, height: 2))
                    }
                }
            }
        }
    }
}

// MARK: - Seeded Random Number Generator

struct SeededRNG: RandomNumberGenerator {
    private var state: UInt64

    init(seed: Int) {
        self.state = UInt64(bitPattern: Int64(seed))
        if self.state == 0 { self.state = 1 }
    }

    mutating func next() -> UInt64 {
        state &+= 0x9E3779B97F4A7C15
        var z = state
        z = (z ^ (z >> 30)) &* 0xBF58476D1CE4E5B9
        z = (z ^ (z >> 27)) &* 0x94D049BB133111EB
        return z ^ (z >> 31)
    }
}
